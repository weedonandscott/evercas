{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EverCas EverCas is a content-addressable file management system. What does that mean? Simply, that EverCas manages a directory where files are saved based on the file\\'s hash. Typical use cases for this kind of system are ones where: Files are written once and never change (e.g. image storage). It\\'s desirable to have no duplicate files (e.g. user uploads). File metadata is stored elsewhere (e.g. in a database). Features Files are stored once and never duplicated. Uses an efficient folder structure optimized for a large number of files. File paths are based on the content hash and are nested based on the first n number of characters. Can save files from local file paths or readable objects (open file handlers, IO buffers, etc). Pluggable put strategies, allowing fine-grained control of how files are added. Able to repair the root folder by reindexing all files. Useful if the hashing algorithm or folder structure options change or to initialize existing files. Supports any hashing algorithm available via hashlib.new . Python 3.10+ compatible. Support for hard-linking files into the EverCas-managed directory on compatible filesystems Links Project: https://github.com/weedonandscott/evercas Documentation: http://evercas.readthedocs.org PyPI: https://pypi.python.org/pypi/evercas/ Quickstart Install using pip: pip install evercas Initialization from evercas import EverCas Designate a root folder for EverCas . If the folder doesn\\'t already exist, it will be created. # Set the `depth` to the number of subfolders the file's hash should be split when saving. # Set the `width` to the desired width of each subfolder. fs = EverCas('temp_evercas', depth=4, width=1, algorithm='sha256') # With depth=4 and width=1, files will be saved in the following pattern: # temp_evercas/a/b/c/d/efghijklmnopqrstuvwxyz # With depth=3 and width=2, files will be saved in the following pattern: # temp_evercas/ab/cd/ef/ghijklmnopqrstuvwxyz NOTE: The algorithm value should be a valid string argument to hashlib.new() . Basic Usage EverCas supports basic file storage, retrieval, and removal as well as some more advanced features like file repair. Storing Content Add content to the folder using either readable objects (e.g. StringIO ) or file paths (e.g. 'a/path/to/some/file' ). from io import StringIO some_content = StringIO('some content') address = fs.put(some_content) # Or if you'd like to save the file with an extension... address = fs.put(some_content, '.txt') # Put all files in a directory for srcpath, address in fs.putdir(\"dir\"): #... # Put all files in a directory tree recursively for srcpath, address in fs.putdir(\"dir\", recursive=True): #... # Put all files in a directory tree using same extensions for srcpath, address in fs.putdir(\"dir\", extensions=True): # address.abspath will have same file extension as srcpath # The id of the file (i.e. the hexdigest of its contents). address.id # The absolute path where the file was saved. address.abspath # The path relative to fs.root. address.relpath # Whether the file previously existed. address.is_duplicate Retrieving File Address Get a file\\'s HashAddress by address ID or path. This address would be identical to the address returned by put() . assert fs.get(address.id) == address assert fs.get(address.relpath) == address assert fs.get(address.abspath) == address assert fs.get('invalid') is None Retrieving Content Get a BufferedReader handler for an existing file by address ID or path. fileio = fs.open(address.id) # Or using the full path... fileio = fs.open(address.abspath) # Or using a path relative to fs.root fileio = fs.open(address.relpath) NOTE: When getting a file that was saved with an extension, it\\'s not necessary to supply the extension. Extensions are ignored when looking for a file based on the ID or path. Removing Content Delete a file by address ID or path. fs.delete(address.id) fs.delete(address.abspath) fs.delete(address.relpath) NOTE: When a file is deleted, any parent directories above the file will also be deleted if they are empty directories. Advanced Usage Below are some of the more advanced features of EverCas . Repairing Files The EverCas files may not always be in sync with it\\'s depth , width , or algorithm settings (e.g. if EverCas takes ownership of a directory that wasn\\'t previously stored using content hashes or if the EverCas settings change). These files can be easily reindexed using repair() . repaired = fs.repair() # Or if you want to drop file extensions... repaired = fs.repair(extensions=False) WARNING: It\\'s recommended that a backup of the directory be made before repairing just in case something goes wrong. Walking Corrupted Files Instead of actually repairing the files, you can iterate over them for custom processing. for corrupted_path, expected_address in fs.corrupted(): # do something WARNING: EverCas.corrupted() is a generator so be aware that modifying the file system while iterating could have unexpected results. Walking All Files Iterate over files. for file in fs.files(): # do something # Or using the class' iter method... for file in fs: # do something Iterate over folders that contain files (i.e. ignore the nested subfolders that only contain folders). for folder in fs.folders(): # do something Computing Size Compute the size in bytes of all files in the root directory. total_bytes = fs.size() Count the total number of files. total_files = fs.count() # Or via len()... total_files = len(fs) Hard-linking files You can use the built-in \\\"link\\\" put strategy to hard-link files into the EverCas directory if the platform and filesystem support it. This will automatically and silently fall back to copying if a hard-link can\\'t be made, e.g. because the source is on a different device, the EverCas directory is on a filesystem that does not support hard links or the source file already has the operating system\\'s maximum allowed number of hard links to it. newpath = fs.put(\"file/path\", put_strategy=\"link\").abspath assert os.path.samefile(\"file/path\", newpath) Custom Put Strategy Fine-grained control over how each file or file-like object is stored in the underlying filesytem. # Implement your own put strategy def my_put_strategy(evercas, src_stream, dst_path): # src_stream is the source data to insert # it is a EverCas.Stream object, which is a Python file-like object # Stream objects also expose the filesystem path of the underlying # file via the src_stream.name property # dst_path is the path generated by EverCas, based on the hash of the # source data # src_stream.name will be None if there is not an underlying file path # available (e.g. a StringIO was passed or some other non-file # file-like) # Its recommended to check name property is available before using if src_stream.name: # Example: rename files instead of copying # (be careful with underlying file paths, make sure to test your # implementation before using it). os.rename(src_stream.name, dst_path) # You can also access properties and methods of the EverCas instance # using the evercas parameter os.chmod(dst_path, EverCas.fmode) else: # The default put strategy is available for use as # PutStrategies.copy # You can manually call other strategies if you want fallbacks # (recommended) PutStrategies.copy(EverCas, src_stream, dst_path) # And use it like: fs.put(\"myfile\", put_strategy=my_put_strategy) For more details, please see the full documentation at http://evercas.readthedocs.org . Acknowledgements This software is based on HashFS, made by @dgilland with @x11x contributions, and inspired by parts of dud, by @kevin-hanselman.","title":"EverCas"},{"location":"#evercas","text":"EverCas is a content-addressable file management system. What does that mean? Simply, that EverCas manages a directory where files are saved based on the file\\'s hash. Typical use cases for this kind of system are ones where: Files are written once and never change (e.g. image storage). It\\'s desirable to have no duplicate files (e.g. user uploads). File metadata is stored elsewhere (e.g. in a database).","title":"EverCas"},{"location":"#features","text":"Files are stored once and never duplicated. Uses an efficient folder structure optimized for a large number of files. File paths are based on the content hash and are nested based on the first n number of characters. Can save files from local file paths or readable objects (open file handlers, IO buffers, etc). Pluggable put strategies, allowing fine-grained control of how files are added. Able to repair the root folder by reindexing all files. Useful if the hashing algorithm or folder structure options change or to initialize existing files. Supports any hashing algorithm available via hashlib.new . Python 3.10+ compatible. Support for hard-linking files into the EverCas-managed directory on compatible filesystems","title":"Features"},{"location":"#links","text":"Project: https://github.com/weedonandscott/evercas Documentation: http://evercas.readthedocs.org PyPI: https://pypi.python.org/pypi/evercas/","title":"Links"},{"location":"#quickstart","text":"Install using pip: pip install evercas","title":"Quickstart"},{"location":"#initialization","text":"from evercas import EverCas Designate a root folder for EverCas . If the folder doesn\\'t already exist, it will be created. # Set the `depth` to the number of subfolders the file's hash should be split when saving. # Set the `width` to the desired width of each subfolder. fs = EverCas('temp_evercas', depth=4, width=1, algorithm='sha256') # With depth=4 and width=1, files will be saved in the following pattern: # temp_evercas/a/b/c/d/efghijklmnopqrstuvwxyz # With depth=3 and width=2, files will be saved in the following pattern: # temp_evercas/ab/cd/ef/ghijklmnopqrstuvwxyz NOTE: The algorithm value should be a valid string argument to hashlib.new() .","title":"Initialization"},{"location":"#basic-usage","text":"EverCas supports basic file storage, retrieval, and removal as well as some more advanced features like file repair.","title":"Basic Usage"},{"location":"#storing-content","text":"Add content to the folder using either readable objects (e.g. StringIO ) or file paths (e.g. 'a/path/to/some/file' ). from io import StringIO some_content = StringIO('some content') address = fs.put(some_content) # Or if you'd like to save the file with an extension... address = fs.put(some_content, '.txt') # Put all files in a directory for srcpath, address in fs.putdir(\"dir\"): #... # Put all files in a directory tree recursively for srcpath, address in fs.putdir(\"dir\", recursive=True): #... # Put all files in a directory tree using same extensions for srcpath, address in fs.putdir(\"dir\", extensions=True): # address.abspath will have same file extension as srcpath # The id of the file (i.e. the hexdigest of its contents). address.id # The absolute path where the file was saved. address.abspath # The path relative to fs.root. address.relpath # Whether the file previously existed. address.is_duplicate","title":"Storing Content"},{"location":"#retrieving-file-address","text":"Get a file\\'s HashAddress by address ID or path. This address would be identical to the address returned by put() . assert fs.get(address.id) == address assert fs.get(address.relpath) == address assert fs.get(address.abspath) == address assert fs.get('invalid') is None","title":"Retrieving File Address"},{"location":"#retrieving-content","text":"Get a BufferedReader handler for an existing file by address ID or path. fileio = fs.open(address.id) # Or using the full path... fileio = fs.open(address.abspath) # Or using a path relative to fs.root fileio = fs.open(address.relpath) NOTE: When getting a file that was saved with an extension, it\\'s not necessary to supply the extension. Extensions are ignored when looking for a file based on the ID or path.","title":"Retrieving Content"},{"location":"#removing-content","text":"Delete a file by address ID or path. fs.delete(address.id) fs.delete(address.abspath) fs.delete(address.relpath) NOTE: When a file is deleted, any parent directories above the file will also be deleted if they are empty directories.","title":"Removing Content"},{"location":"#advanced-usage","text":"Below are some of the more advanced features of EverCas .","title":"Advanced Usage"},{"location":"#repairing-files","text":"The EverCas files may not always be in sync with it\\'s depth , width , or algorithm settings (e.g. if EverCas takes ownership of a directory that wasn\\'t previously stored using content hashes or if the EverCas settings change). These files can be easily reindexed using repair() . repaired = fs.repair() # Or if you want to drop file extensions... repaired = fs.repair(extensions=False) WARNING: It\\'s recommended that a backup of the directory be made before repairing just in case something goes wrong.","title":"Repairing Files"},{"location":"#walking-corrupted-files","text":"Instead of actually repairing the files, you can iterate over them for custom processing. for corrupted_path, expected_address in fs.corrupted(): # do something WARNING: EverCas.corrupted() is a generator so be aware that modifying the file system while iterating could have unexpected results.","title":"Walking Corrupted Files"},{"location":"#walking-all-files","text":"Iterate over files. for file in fs.files(): # do something # Or using the class' iter method... for file in fs: # do something Iterate over folders that contain files (i.e. ignore the nested subfolders that only contain folders). for folder in fs.folders(): # do something","title":"Walking All Files"},{"location":"#computing-size","text":"Compute the size in bytes of all files in the root directory. total_bytes = fs.size() Count the total number of files. total_files = fs.count() # Or via len()... total_files = len(fs)","title":"Computing Size"},{"location":"#hard-linking-files","text":"You can use the built-in \\\"link\\\" put strategy to hard-link files into the EverCas directory if the platform and filesystem support it. This will automatically and silently fall back to copying if a hard-link can\\'t be made, e.g. because the source is on a different device, the EverCas directory is on a filesystem that does not support hard links or the source file already has the operating system\\'s maximum allowed number of hard links to it. newpath = fs.put(\"file/path\", put_strategy=\"link\").abspath assert os.path.samefile(\"file/path\", newpath)","title":"Hard-linking files"},{"location":"#custom-put-strategy","text":"Fine-grained control over how each file or file-like object is stored in the underlying filesytem. # Implement your own put strategy def my_put_strategy(evercas, src_stream, dst_path): # src_stream is the source data to insert # it is a EverCas.Stream object, which is a Python file-like object # Stream objects also expose the filesystem path of the underlying # file via the src_stream.name property # dst_path is the path generated by EverCas, based on the hash of the # source data # src_stream.name will be None if there is not an underlying file path # available (e.g. a StringIO was passed or some other non-file # file-like) # Its recommended to check name property is available before using if src_stream.name: # Example: rename files instead of copying # (be careful with underlying file paths, make sure to test your # implementation before using it). os.rename(src_stream.name, dst_path) # You can also access properties and methods of the EverCas instance # using the evercas parameter os.chmod(dst_path, EverCas.fmode) else: # The default put strategy is available for use as # PutStrategies.copy # You can manually call other strategies if you want fallbacks # (recommended) PutStrategies.copy(EverCas, src_stream, dst_path) # And use it like: fs.put(\"myfile\", put_strategy=my_put_strategy) For more details, please see the full documentation at http://evercas.readthedocs.org .","title":"Custom Put Strategy"},{"location":"#acknowledgements","text":"This software is based on HashFS, made by @dgilland with @x11x contributions, and inspired by parts of dud, by @kevin-hanselman.","title":"Acknowledgements"},{"location":"api/","text":"API Reference Module for EverCas class. EverCas Bases: object Content addressable file manager. Attributes: Name Type Description root str Directory path used as root of storage space. depth int Depth of subfolders to create when saving a file. width int Width of each subfolder to create when saving a file. algorithm str Hash algorithm to use when computing file hash. Algorithm should be available in hashlib module. Defaults to 'sha256' . fmode int File mode permission to set when adding files to directory. Defaults to 0o664 which allows owner/group to read/write and everyone else to read. dmode int Directory mode permission to set for subdirectories. Defaults to 0o755 which allows owner/group to read/write and everyone else to read and everyone to execute. put_strategy mixed Default put_strategy for :meth: put method. See :meth: put for more information. Defaults to :attr: PutStrategies.copy . lowercase_extensions bool Normalize all file extensions to lower case when adding files. Defaults to False . Source code in evercas/evercas.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 class EverCas ( object ): \"\"\"Content addressable file manager. Attributes: root (str): Directory path used as root of storage space. depth (int, optional): Depth of subfolders to create when saving a file. width (int, optional): Width of each subfolder to create when saving a file. algorithm (str): Hash algorithm to use when computing file hash. Algorithm should be available in ``hashlib`` module. Defaults to ``'sha256'``. fmode (int, optional): File mode permission to set when adding files to directory. Defaults to ``0o664`` which allows owner/group to read/write and everyone else to read. dmode (int, optional): Directory mode permission to set for subdirectories. Defaults to ``0o755`` which allows owner/group to read/write and everyone else to read and everyone to execute. put_strategy (mixed, optional): Default ``put_strategy`` for :meth:`put` method. See :meth:`put` for more information. Defaults to :attr:`PutStrategies.copy`. lowercase_extensions (bool, optional): Normalize all file extensions to lower case when adding files. Defaults to ``False``. \"\"\" def __init__ ( self , root , depth = 4 , width = 1 , algorithm = \"sha256\" , fmode = 0o664 , dmode = 0o755 , put_strategy = None , lowercase_extensions = False , ): self . root = os . path . realpath ( root ) self . depth = depth self . width = width self . algorithm = algorithm self . fmode = fmode self . dmode = dmode self . put_strategy = PutStrategies . get ( put_strategy ) or PutStrategies . copy self . lowercase_extensions = lowercase_extensions def put ( self , file , extension = None , put_strategy = None , simulate = False ): \"\"\"Store contents of `file` on disk using its content hash for the address. Args: file (mixed): Readable object or path to file. extension (str, optional): Optional extension to append to file when saving. put_strategy (mixed, optional): The strategy to use for adding files; may be a function or the string name of one of the built-in put strategies declared in :class:`PutStrategies` class. Defaults to :attr:`PutStrategies.copy`. simulate (bool, optional): Return the :class:`HashAddress` of the file that would be appended but don't do anything. Put strategies are functions ``(evercas, stream, filepath)`` where ``evercas`` is the :class:`EverCas` instance from which :meth:`put` was called; ``stream`` is the :class:`Stream` object representing the data to add; and ``filepath`` is the string absolute file path inside the EverCas where it needs to be saved. The put strategy function should create the path ``filepath`` containing the data in ``stream``. There are currently two built-in put strategies: \"copy\" (the default) and \"link\". \"link\" attempts to hard link the file into the EverCas if the platform and underlying filesystem support it, and falls back to \"copy\" behaviour. Returns: HashAddress: File's hash address. \"\"\" stream = Stream ( file ) if extension and self . lowercase_extensions : extension = extension . lower () with closing ( stream ): id = self . computehash ( stream ) filepath = self . idpath ( id , extension ) # Only move file if it doesn't already exist. if not os . path . isfile ( filepath ): is_duplicate = False if not simulate : self . makepath ( os . path . dirname ( filepath )) put_strategy = ( PutStrategies . get ( put_strategy ) or self . put_strategy or PutStrategies . copy ) put_strategy ( self , stream , filepath ) else : is_duplicate = True return HashAddress ( id , self . relpath ( filepath ), filepath , is_duplicate ) def putdir ( self , root , extensions = True , recursive = False , ** kwargs ): \"\"\"Put all files from a directory. Args: root (str): Path to the directory to add. extensions (bool, optional): Whether to add extensions when saving (extension will be taken from input file). Defaults to ``True``. recursive (bool, optional): Find files recursively in ``root``. Defaults to ``False``. put_strategy (mixed, optional): same as :meth:`put`. simulate (boo, optional): same as :meth:`put`. Yields :class:`HashAddress`es for all added files. \"\"\" for file in find_files ( root , recursive = recursive ): extension = os . path . splitext ( file )[ 1 ] if extensions else None address = self . put ( file , extension = extension , ** kwargs ) yield ( file , address ) def _mktempfile ( self , stream ): \"\"\"Create a named temporary file from a :class:`Stream` object and return its filename. \"\"\" tmp = NamedTemporaryFile ( delete = False ) if self . fmode is not None : oldmask = os . umask ( 0 ) try : os . chmod ( tmp . name , self . fmode ) finally : os . umask ( oldmask ) for data in stream : tmp . write ( to_bytes ( data )) tmp . close () return tmp . name def get ( self , file ): \"\"\"Return :class:`HashAdress` from given id or path. If `file` does not refer to a valid file, then ``None`` is returned. Args: file (str): Address ID or path of file. Returns: HashAddress: File's hash address. \"\"\" realpath = self . realpath ( file ) if realpath is None : return None else : return HashAddress ( self . unshard ( realpath ), self . relpath ( realpath ), realpath ) def open ( self , file , mode = \"rb\" ): \"\"\"Return open buffer object from given id or path. Args: file (str): Address ID or path of file. mode (str, optional): Mode to open file in. Defaults to ``'rb'``. Returns: Buffer: An ``io`` buffer dependent on the `mode`. Raises: IOError: If file doesn't exist. \"\"\" realpath = self . realpath ( file ) if realpath is None : raise IOError ( \"Could not locate file: {0} \" . format ( file )) return io . open ( realpath , mode ) def delete ( self , file ): \"\"\"Delete file using id or path. Remove any empty directories after deleting. No exception is raised if file doesn't exist. Args: file (str): Address ID or path of file. \"\"\" realpath = self . realpath ( file ) if realpath is None : return try : os . remove ( realpath ) except OSError : # pragma: no cover pass else : self . remove_empty ( os . path . dirname ( realpath )) def remove_empty ( self , subpath ): \"\"\"Successively remove all empty folders starting with `subpath` and proceeding \"up\" through directory tree until reaching the :attr:`root` folder. \"\"\" # Don't attempt to remove any folders if subpath is not a # subdirectory of the root directory. if not self . haspath ( subpath ): return while subpath != self . root : if len ( os . listdir ( subpath )) > 0 or os . path . islink ( subpath ): break os . rmdir ( subpath ) subpath = os . path . dirname ( subpath ) def files ( self ): \"\"\"Return generator that yields all files in the :attr:`root` directory. \"\"\" for file in find_files ( self . root , recursive = True ): yield os . path . abspath ( file ) def folders ( self ): \"\"\"Return generator that yields all folders in the :attr:`root` directory that contain files. \"\"\" for folder , subfolders , files in os . walk ( self . root ): if files : yield folder def count ( self ): \"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\" count = 0 for _ in self : count += 1 return count def size ( self ): \"\"\"Return the total size in bytes of all files in the :attr:`root` directory. \"\"\" total = 0 for path in self . files (): total += os . path . getsize ( path ) return total def exists ( self , file ): \"\"\"Check whether a given file id or path exists on disk.\"\"\" return bool ( self . realpath ( file )) def haspath ( self , path ): \"\"\"Return whether `path` is a subdirectory of the :attr:`root` directory. \"\"\" return issubdir ( path , self . root ) def makepath ( self , path ): \"\"\"Physically create the folder path on disk.\"\"\" try : os . makedirs ( path , self . dmode ) except FileExistsError : assert os . path . isdir ( path ), \"expected {} to be a directory\" . format ( path ) def relpath ( self , path ): \"\"\"Return `path` relative to the :attr:`root` directory.\"\"\" return os . path . relpath ( path , self . root ) def realpath ( self , file ): \"\"\"Attempt to determine the real path of a file id or path through successive checking of candidate paths. If the real path is stored with an extension, the path is considered a match if the basename matches the expected file path of the id. \"\"\" # Check for absoluate path. if os . path . isfile ( file ): return file # Check for relative path. relpath = os . path . join ( self . root , file ) if os . path . isfile ( relpath ): return relpath # Check for sharded path. filepath = self . idpath ( file ) if os . path . isfile ( filepath ): return filepath # Check for sharded path with any extension. paths = glob . glob ( \" {0} .*\" . format ( filepath )) if paths : return paths [ 0 ] # Could not determine a match. return None def idpath ( self , id , extension = \"\" ): \"\"\"Build the file path for a given hash id. Optionally, append a file extension. \"\"\" paths = self . shard ( id ) if extension and not extension . startswith ( os . extsep ): extension = os . extsep + extension elif not extension : extension = \"\" return os . path . join ( self . root , * paths ) + extension def computehash ( self , stream ): \"\"\"Compute hash of file using :attr:`algorithm`.\"\"\" hashobj = hashlib . new ( self . algorithm ) for data in stream : hashobj . update ( to_bytes ( data )) return hashobj . hexdigest () def shard ( self , id ): \"\"\"Shard content ID into subfolders.\"\"\" return shard ( id , self . depth , self . width ) def unshard ( self , path ): \"\"\"Unshard path to determine hash value.\"\"\" if not self . haspath ( path ): raise ValueError ( \"Cannot unshard path. The path {0!r} is not \" \"a subdirectory of the root directory {1!r} \" . format ( path , self . root ) ) return os . path . splitext ( self . relpath ( path ))[ 0 ] . replace ( os . sep , \"\" ) def repair ( self , extensions = True ): \"\"\"Repair any file locations whose content address doesn't match it's file path. \"\"\" repaired = [] corrupted = tuple ( self . corrupted ( extensions = extensions )) oldmask = os . umask ( 0 ) try : for path , address in corrupted : if os . path . isfile ( address . abspath ): # File already exists so just delete corrupted path. os . remove ( path ) else : # File doesn't exists so move it. self . makepath ( os . path . dirname ( address . abspath )) shutil . move ( path , address . abspath ) os . chmod ( address . abspath , self . fmode ) repaired . append (( path , address )) finally : os . umask ( oldmask ) return repaired def corrupted ( self , extensions = True ): \"\"\"Return generator that yields corrupted files as ``(path, address)`` where ``path`` is the path of the corrupted file and ``address`` is the :class:`HashAddress` of the expected location. \"\"\" for path in self . files (): stream = Stream ( path ) with closing ( stream ): id = self . computehash ( stream ) extension = os . path . splitext ( path )[ 1 ] if extensions else None expected_path = self . idpath ( id , extension ) if expected_path != path : yield ( path , HashAddress ( id , self . relpath ( expected_path ), expected_path ), ) def __contains__ ( self , file ): \"\"\"Return whether a given file id or path is contained in the :attr:`root` directory. \"\"\" return self . exists ( file ) def __iter__ ( self ): \"\"\"Iterate over all files in the :attr:`root` directory.\"\"\" return self . files () def __len__ ( self ): \"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\" return self . count () __contains__ ( file ) Return whether a given file id or path is contained in the :attr: root directory. Source code in evercas/evercas.py 389 390 391 392 393 def __contains__ ( self , file ): \"\"\"Return whether a given file id or path is contained in the :attr:`root` directory. \"\"\" return self . exists ( file ) __iter__ () Iterate over all files in the :attr: root directory. Source code in evercas/evercas.py 395 396 397 def __iter__ ( self ): \"\"\"Iterate over all files in the :attr:`root` directory.\"\"\" return self . files () __len__ () Return count of the number of files in the :attr: root directory. Source code in evercas/evercas.py 399 400 401 def __len__ ( self ): \"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\" return self . count () computehash ( stream ) Compute hash of file using :attr: algorithm . Source code in evercas/evercas.py 323 324 325 326 327 328 def computehash ( self , stream ): \"\"\"Compute hash of file using :attr:`algorithm`.\"\"\" hashobj = hashlib . new ( self . algorithm ) for data in stream : hashobj . update ( to_bytes ( data )) return hashobj . hexdigest () corrupted ( extensions = True ) Return generator that yields corrupted files as (path, address) where path is the path of the corrupted file and address is the :class: HashAddress of the expected location. Source code in evercas/evercas.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def corrupted ( self , extensions = True ): \"\"\"Return generator that yields corrupted files as ``(path, address)`` where ``path`` is the path of the corrupted file and ``address`` is the :class:`HashAddress` of the expected location. \"\"\" for path in self . files (): stream = Stream ( path ) with closing ( stream ): id = self . computehash ( stream ) extension = os . path . splitext ( path )[ 1 ] if extensions else None expected_path = self . idpath ( id , extension ) if expected_path != path : yield ( path , HashAddress ( id , self . relpath ( expected_path ), expected_path ), ) count () Return count of the number of files in the :attr: root directory. Source code in evercas/evercas.py 243 244 245 246 247 248 def count ( self ): \"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\" count = 0 for _ in self : count += 1 return count delete ( file ) Delete file using id or path. Remove any empty directories after deleting. No exception is raised if file doesn't exist. Parameters: Name Type Description Default file str Address ID or path of file. required Source code in evercas/evercas.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def delete ( self , file ): \"\"\"Delete file using id or path. Remove any empty directories after deleting. No exception is raised if file doesn't exist. Args: file (str): Address ID or path of file. \"\"\" realpath = self . realpath ( file ) if realpath is None : return try : os . remove ( realpath ) except OSError : # pragma: no cover pass else : self . remove_empty ( os . path . dirname ( realpath )) exists ( file ) Check whether a given file id or path exists on disk. Source code in evercas/evercas.py 261 262 263 def exists ( self , file ): \"\"\"Check whether a given file id or path exists on disk.\"\"\" return bool ( self . realpath ( file )) files () Return generator that yields all files in the :attr: root directory. Source code in evercas/evercas.py 228 229 230 231 232 233 def files ( self ): \"\"\"Return generator that yields all files in the :attr:`root` directory. \"\"\" for file in find_files ( self . root , recursive = True ): yield os . path . abspath ( file ) folders () Return generator that yields all folders in the :attr: root directory that contain files. Source code in evercas/evercas.py 235 236 237 238 239 240 241 def folders ( self ): \"\"\"Return generator that yields all folders in the :attr:`root` directory that contain files. \"\"\" for folder , subfolders , files in os . walk ( self . root ): if files : yield folder get ( file ) Return :class: HashAdress from given id or path. If file does not refer to a valid file, then None is returned. Parameters: Name Type Description Default file str Address ID or path of file. required Returns: Name Type Description HashAddress File's hash address. Source code in evercas/evercas.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def get ( self , file ): \"\"\"Return :class:`HashAdress` from given id or path. If `file` does not refer to a valid file, then ``None`` is returned. Args: file (str): Address ID or path of file. Returns: HashAddress: File's hash address. \"\"\" realpath = self . realpath ( file ) if realpath is None : return None else : return HashAddress ( self . unshard ( realpath ), self . relpath ( realpath ), realpath ) haspath ( path ) Return whether path is a subdirectory of the :attr: root directory. Source code in evercas/evercas.py 265 266 267 268 269 def haspath ( self , path ): \"\"\"Return whether `path` is a subdirectory of the :attr:`root` directory. \"\"\" return issubdir ( path , self . root ) idpath ( id , extension = '' ) Build the file path for a given hash id. Optionally, append a file extension. Source code in evercas/evercas.py 310 311 312 313 314 315 316 317 318 319 320 321 def idpath ( self , id , extension = \"\" ): \"\"\"Build the file path for a given hash id. Optionally, append a file extension. \"\"\" paths = self . shard ( id ) if extension and not extension . startswith ( os . extsep ): extension = os . extsep + extension elif not extension : extension = \"\" return os . path . join ( self . root , * paths ) + extension makepath ( path ) Physically create the folder path on disk. Source code in evercas/evercas.py 271 272 273 274 275 276 def makepath ( self , path ): \"\"\"Physically create the folder path on disk.\"\"\" try : os . makedirs ( path , self . dmode ) except FileExistsError : assert os . path . isdir ( path ), \"expected {} to be a directory\" . format ( path ) open ( file , mode = 'rb' ) Return open buffer object from given id or path. Parameters: Name Type Description Default file str Address ID or path of file. required mode str Mode to open file in. Defaults to 'rb' . 'rb' Returns: Name Type Description Buffer An io buffer dependent on the mode . Raises: Type Description IOError If file doesn't exist. Source code in evercas/evercas.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def open ( self , file , mode = \"rb\" ): \"\"\"Return open buffer object from given id or path. Args: file (str): Address ID or path of file. mode (str, optional): Mode to open file in. Defaults to ``'rb'``. Returns: Buffer: An ``io`` buffer dependent on the `mode`. Raises: IOError: If file doesn't exist. \"\"\" realpath = self . realpath ( file ) if realpath is None : raise IOError ( \"Could not locate file: {0} \" . format ( file )) return io . open ( realpath , mode ) put ( file , extension = None , put_strategy = None , simulate = False ) Store contents of file on disk using its content hash for the address. Parameters: Name Type Description Default file mixed Readable object or path to file. required extension str Optional extension to append to file when saving. None put_strategy mixed The strategy to use for adding files; may be a function or the string name of one of the built-in put strategies declared in :class: PutStrategies class. Defaults to :attr: PutStrategies.copy . None simulate bool Return the :class: HashAddress of the file that would be appended but don't do anything. False Put strategies are functions (evercas, stream, filepath) where evercas is the :class: EverCas instance from which :meth: put was called; stream is the :class: Stream object representing the data to add; and filepath is the string absolute file path inside the EverCas where it needs to be saved. The put strategy function should create the path filepath containing the data in stream . There are currently two built-in put strategies: \"copy\" (the default) and \"link\". \"link\" attempts to hard link the file into the EverCas if the platform and underlying filesystem support it, and falls back to \"copy\" behaviour. Returns: Name Type Description HashAddress File's hash address. Source code in evercas/evercas.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def put ( self , file , extension = None , put_strategy = None , simulate = False ): \"\"\"Store contents of `file` on disk using its content hash for the address. Args: file (mixed): Readable object or path to file. extension (str, optional): Optional extension to append to file when saving. put_strategy (mixed, optional): The strategy to use for adding files; may be a function or the string name of one of the built-in put strategies declared in :class:`PutStrategies` class. Defaults to :attr:`PutStrategies.copy`. simulate (bool, optional): Return the :class:`HashAddress` of the file that would be appended but don't do anything. Put strategies are functions ``(evercas, stream, filepath)`` where ``evercas`` is the :class:`EverCas` instance from which :meth:`put` was called; ``stream`` is the :class:`Stream` object representing the data to add; and ``filepath`` is the string absolute file path inside the EverCas where it needs to be saved. The put strategy function should create the path ``filepath`` containing the data in ``stream``. There are currently two built-in put strategies: \"copy\" (the default) and \"link\". \"link\" attempts to hard link the file into the EverCas if the platform and underlying filesystem support it, and falls back to \"copy\" behaviour. Returns: HashAddress: File's hash address. \"\"\" stream = Stream ( file ) if extension and self . lowercase_extensions : extension = extension . lower () with closing ( stream ): id = self . computehash ( stream ) filepath = self . idpath ( id , extension ) # Only move file if it doesn't already exist. if not os . path . isfile ( filepath ): is_duplicate = False if not simulate : self . makepath ( os . path . dirname ( filepath )) put_strategy = ( PutStrategies . get ( put_strategy ) or self . put_strategy or PutStrategies . copy ) put_strategy ( self , stream , filepath ) else : is_duplicate = True return HashAddress ( id , self . relpath ( filepath ), filepath , is_duplicate ) putdir ( root , extensions = True , recursive = False , ** kwargs ) Put all files from a directory. Parameters: Name Type Description Default root str Path to the directory to add. required extensions bool Whether to add extensions when saving (extension will be taken from input file). Defaults to True . True recursive bool Find files recursively in root . Defaults to False . False put_strategy mixed same as :meth: put . required simulate boo same as :meth: put . required Yields :class: HashAddress es for all added files. Source code in evercas/evercas.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def putdir ( self , root , extensions = True , recursive = False , ** kwargs ): \"\"\"Put all files from a directory. Args: root (str): Path to the directory to add. extensions (bool, optional): Whether to add extensions when saving (extension will be taken from input file). Defaults to ``True``. recursive (bool, optional): Find files recursively in ``root``. Defaults to ``False``. put_strategy (mixed, optional): same as :meth:`put`. simulate (boo, optional): same as :meth:`put`. Yields :class:`HashAddress`es for all added files. \"\"\" for file in find_files ( root , recursive = recursive ): extension = os . path . splitext ( file )[ 1 ] if extensions else None address = self . put ( file , extension = extension , ** kwargs ) yield ( file , address ) realpath ( file ) Attempt to determine the real path of a file id or path through successive checking of candidate paths. If the real path is stored with an extension, the path is considered a match if the basename matches the expected file path of the id. Source code in evercas/evercas.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def realpath ( self , file ): \"\"\"Attempt to determine the real path of a file id or path through successive checking of candidate paths. If the real path is stored with an extension, the path is considered a match if the basename matches the expected file path of the id. \"\"\" # Check for absoluate path. if os . path . isfile ( file ): return file # Check for relative path. relpath = os . path . join ( self . root , file ) if os . path . isfile ( relpath ): return relpath # Check for sharded path. filepath = self . idpath ( file ) if os . path . isfile ( filepath ): return filepath # Check for sharded path with any extension. paths = glob . glob ( \" {0} .*\" . format ( filepath )) if paths : return paths [ 0 ] # Could not determine a match. return None relpath ( path ) Return path relative to the :attr: root directory. Source code in evercas/evercas.py 278 279 280 def relpath ( self , path ): \"\"\"Return `path` relative to the :attr:`root` directory.\"\"\" return os . path . relpath ( path , self . root ) remove_empty ( subpath ) Successively remove all empty folders starting with subpath and proceeding \"up\" through directory tree until reaching the :attr: root folder. Source code in evercas/evercas.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def remove_empty ( self , subpath ): \"\"\"Successively remove all empty folders starting with `subpath` and proceeding \"up\" through directory tree until reaching the :attr:`root` folder. \"\"\" # Don't attempt to remove any folders if subpath is not a # subdirectory of the root directory. if not self . haspath ( subpath ): return while subpath != self . root : if len ( os . listdir ( subpath )) > 0 or os . path . islink ( subpath ): break os . rmdir ( subpath ) subpath = os . path . dirname ( subpath ) repair ( extensions = True ) Repair any file locations whose content address doesn't match it's file path. Source code in evercas/evercas.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def repair ( self , extensions = True ): \"\"\"Repair any file locations whose content address doesn't match it's file path. \"\"\" repaired = [] corrupted = tuple ( self . corrupted ( extensions = extensions )) oldmask = os . umask ( 0 ) try : for path , address in corrupted : if os . path . isfile ( address . abspath ): # File already exists so just delete corrupted path. os . remove ( path ) else : # File doesn't exists so move it. self . makepath ( os . path . dirname ( address . abspath )) shutil . move ( path , address . abspath ) os . chmod ( address . abspath , self . fmode ) repaired . append (( path , address )) finally : os . umask ( oldmask ) return repaired shard ( id ) Shard content ID into subfolders. Source code in evercas/evercas.py 330 331 332 def shard ( self , id ): \"\"\"Shard content ID into subfolders.\"\"\" return shard ( id , self . depth , self . width ) size () Return the total size in bytes of all files in the :attr: root directory. Source code in evercas/evercas.py 250 251 252 253 254 255 256 257 258 259 def size ( self ): \"\"\"Return the total size in bytes of all files in the :attr:`root` directory. \"\"\" total = 0 for path in self . files (): total += os . path . getsize ( path ) return total unshard ( path ) Unshard path to determine hash value. Source code in evercas/evercas.py 334 335 336 337 338 339 340 341 342 def unshard ( self , path ): \"\"\"Unshard path to determine hash value.\"\"\" if not self . haspath ( path ): raise ValueError ( \"Cannot unshard path. The path {0!r} is not \" \"a subdirectory of the root directory {1!r} \" . format ( path , self . root ) ) return os . path . splitext ( self . relpath ( path ))[ 0 ] . replace ( os . sep , \"\" ) HashAddress Bases: namedtuple ( HashAddress , [ id , relpath , abspath , is_duplicate ]) File address containing file's path on disk and it's content hash ID. Attributes: Name Type Description id str Hash ID (hexdigest) of file contents. relpath str Relative path location to :attr: EverCas.root . abspath str Absoluate path location of file on disk. is_duplicate boolean Whether the hash address created was a duplicate of a previously existing file. Can only be True after a put operation. Defaults to False . Source code in evercas/evercas.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 class HashAddress ( namedtuple ( \"HashAddress\" , [ \"id\" , \"relpath\" , \"abspath\" , \"is_duplicate\" ]) ): \"\"\"File address containing file's path on disk and it's content hash ID. Attributes: id (str): Hash ID (hexdigest) of file contents. relpath (str): Relative path location to :attr:`EverCas.root`. abspath (str): Absoluate path location of file on disk. is_duplicate (boolean, optional): Whether the hash address created was a duplicate of a previously existing file. Can only be ``True`` after a put operation. Defaults to ``False``. \"\"\" def __new__ ( cls , id , relpath , abspath , is_duplicate = False ): return super ( HashAddress , cls ) . __new__ ( cls , id , relpath , abspath , is_duplicate ) PutStrategies Namespace for built-in put strategies. Should not be instantiated. Use the :meth: get static method to look up a strategy by name, or directly reference one of the included class methods. Source code in evercas/evercas.py 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 class PutStrategies : \"\"\"Namespace for built-in put strategies. Should not be instantiated. Use the :meth:`get` static method to look up a strategy by name, or directly reference one of the included class methods. \"\"\" @classmethod def get ( cls , method ): \"\"\"Look up a stragegy by name string. You can also pass a function which will be returned as is.\"\"\" if method : if method == \"get\" : raise ValueError ( \"invalid put strategy name, 'get'\" ) return method if callable ( method ) else getattr ( cls , method ) @staticmethod def copy ( evercas , src_stream , dst_path ): \"\"\"The default copy put strategy, writes the file object to a temporary file on disk and then moves it into place.\"\"\" shutil . move ( evercas . _mktempfile ( src_stream ), dst_path ) if hasattr ( os , \"link\" ): @classmethod def link ( cls , evercas , src_stream , dst_path ): \"\"\"Use os.link if available to create a hard link to the original file if the EverCas and the original file reside on the same filesystem and the filesystem supports hard links.\"\"\" # Get the original file path exposed by the Stream instance src_path = src_stream . name # No path available because e.g. a StringIO was used if not src_path : # Just copy return cls . copy ( evercas , src_stream , dst_path ) try : # Try to create the hard link os . link ( src_path , dst_path ) except EnvironmentError as e : # These are link specific errors. If any of these 3 are raised # we try to copy instead # EMLINK - src already has the maximum number of links to it # EXDEV - invalid cross-device link # EPERM - the dst filesystem does not support hard links # (note EPERM could also be another permissions error; these # will be raised again when we try to copy) if e . errno not in ( errno . EMLINK , errno . EXDEV , errno . EPERM ): raise return cls . copy ( evercas , src_stream , dst_path ) else : # After creating the hard link, make sure it has the correct # file permissions os . chmod ( dst_path , evercas . fmode ) else : # Platform does not support os.link, so use the default copy strategy # instead link = copy copy ( evercas , src_stream , dst_path ) staticmethod The default copy put strategy, writes the file object to a temporary file on disk and then moves it into place. Source code in evercas/evercas.py 538 539 540 541 542 @staticmethod def copy ( evercas , src_stream , dst_path ): \"\"\"The default copy put strategy, writes the file object to a temporary file on disk and then moves it into place.\"\"\" shutil . move ( evercas . _mktempfile ( src_stream ), dst_path ) get ( method ) classmethod Look up a stragegy by name string. You can also pass a function which will be returned as is. Source code in evercas/evercas.py 529 530 531 532 533 534 535 536 @classmethod def get ( cls , method ): \"\"\"Look up a stragegy by name string. You can also pass a function which will be returned as is.\"\"\" if method : if method == \"get\" : raise ValueError ( \"invalid put strategy name, 'get'\" ) return method if callable ( method ) else getattr ( cls , method ) link ( evercas , src_stream , dst_path ) classmethod Use os.link if available to create a hard link to the original file if the EverCas and the original file reside on the same filesystem and the filesystem supports hard links. Source code in evercas/evercas.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 @classmethod def link ( cls , evercas , src_stream , dst_path ): \"\"\"Use os.link if available to create a hard link to the original file if the EverCas and the original file reside on the same filesystem and the filesystem supports hard links.\"\"\" # Get the original file path exposed by the Stream instance src_path = src_stream . name # No path available because e.g. a StringIO was used if not src_path : # Just copy return cls . copy ( evercas , src_stream , dst_path ) try : # Try to create the hard link os . link ( src_path , dst_path ) except EnvironmentError as e : # These are link specific errors. If any of these 3 are raised # we try to copy instead # EMLINK - src already has the maximum number of links to it # EXDEV - invalid cross-device link # EPERM - the dst filesystem does not support hard links # (note EPERM could also be another permissions error; these # will be raised again when we try to copy) if e . errno not in ( errno . EMLINK , errno . EXDEV , errno . EPERM ): raise return cls . copy ( evercas , src_stream , dst_path ) else : # After creating the hard link, make sure it has the correct # file permissions os . chmod ( dst_path , evercas . fmode ) Stream Bases: object Common interface for file-like objects. The input obj can be a file-like object or a path to a file. If obj is a path to a file, then it will be opened until :meth: close is called. If obj is a file-like object, then it's original position will be restored when :meth: close is called instead of closing the object automatically. Closing of the stream is deferred to whatever process passed the stream in. Successive readings of the stream is supported without having to manually set it's position back to 0 . Source code in evercas/evercas.py 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 class Stream ( object ): \"\"\"Common interface for file-like objects. The input `obj` can be a file-like object or a path to a file. If `obj` is a path to a file, then it will be opened until :meth:`close` is called. If `obj` is a file-like object, then it's original position will be restored when :meth:`close` is called instead of closing the object automatically. Closing of the stream is deferred to whatever process passed the stream in. Successive readings of the stream is supported without having to manually set it's position back to ``0``. \"\"\" def __init__ ( self , obj ): if hasattr ( obj , \"read\" ): pos = obj . tell () elif os . path . isfile ( obj ): obj = io . open ( obj , \"rb\" ) pos = None else : raise ValueError ( \"Object must be a valid file path or a readable object\" ) try : file_stat = os . stat ( obj . name ) buffer_size = file_stat . st_blksize except Exception : buffer_size = 8192 try : # Expose the original file path if available. # This allows put strategies to use OS functions, working with # paths, instead of being limited to the API provided by Python # file-like objects # name property can also hold int fd, so we make it None in that # case self . name = None if isinstance ( obj . name , int ) else obj . name except AttributeError : self . name = None self . _obj = obj self . _pos = pos self . _buffer_size = buffer_size def __iter__ ( self ): \"\"\"Read underlying IO object and yield results. Return object to original position if we didn't open it originally. \"\"\" self . _obj . seek ( 0 ) while True : data = self . _obj . read ( self . _buffer_size ) if not data : break yield data if self . _pos is not None : self . _obj . seek ( self . _pos ) def close ( self ): \"\"\"Close underlying IO object if we opened it, else return it to original position. \"\"\" if self . _pos is None : self . _obj . close () else : self . _obj . seek ( self . _pos ) __iter__ () Read underlying IO object and yield results. Return object to original position if we didn't open it originally. Source code in evercas/evercas.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def __iter__ ( self ): \"\"\"Read underlying IO object and yield results. Return object to original position if we didn't open it originally. \"\"\" self . _obj . seek ( 0 ) while True : data = self . _obj . read ( self . _buffer_size ) if not data : break yield data if self . _pos is not None : self . _obj . seek ( self . _pos ) close () Close underlying IO object if we opened it, else return it to original position. Source code in evercas/evercas.py 512 513 514 515 516 517 518 519 def close ( self ): \"\"\"Close underlying IO object if we opened it, else return it to original position. \"\"\" if self . _pos is None : self . _obj . close () else : self . _obj . seek ( self . _pos )","title":"API Reference"},{"location":"api/#api-reference","text":"Module for EverCas class.","title":"API Reference"},{"location":"api/#evercas.evercas.EverCas","text":"Bases: object Content addressable file manager. Attributes: Name Type Description root str Directory path used as root of storage space. depth int Depth of subfolders to create when saving a file. width int Width of each subfolder to create when saving a file. algorithm str Hash algorithm to use when computing file hash. Algorithm should be available in hashlib module. Defaults to 'sha256' . fmode int File mode permission to set when adding files to directory. Defaults to 0o664 which allows owner/group to read/write and everyone else to read. dmode int Directory mode permission to set for subdirectories. Defaults to 0o755 which allows owner/group to read/write and everyone else to read and everyone to execute. put_strategy mixed Default put_strategy for :meth: put method. See :meth: put for more information. Defaults to :attr: PutStrategies.copy . lowercase_extensions bool Normalize all file extensions to lower case when adding files. Defaults to False . Source code in evercas/evercas.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 class EverCas ( object ): \"\"\"Content addressable file manager. Attributes: root (str): Directory path used as root of storage space. depth (int, optional): Depth of subfolders to create when saving a file. width (int, optional): Width of each subfolder to create when saving a file. algorithm (str): Hash algorithm to use when computing file hash. Algorithm should be available in ``hashlib`` module. Defaults to ``'sha256'``. fmode (int, optional): File mode permission to set when adding files to directory. Defaults to ``0o664`` which allows owner/group to read/write and everyone else to read. dmode (int, optional): Directory mode permission to set for subdirectories. Defaults to ``0o755`` which allows owner/group to read/write and everyone else to read and everyone to execute. put_strategy (mixed, optional): Default ``put_strategy`` for :meth:`put` method. See :meth:`put` for more information. Defaults to :attr:`PutStrategies.copy`. lowercase_extensions (bool, optional): Normalize all file extensions to lower case when adding files. Defaults to ``False``. \"\"\" def __init__ ( self , root , depth = 4 , width = 1 , algorithm = \"sha256\" , fmode = 0o664 , dmode = 0o755 , put_strategy = None , lowercase_extensions = False , ): self . root = os . path . realpath ( root ) self . depth = depth self . width = width self . algorithm = algorithm self . fmode = fmode self . dmode = dmode self . put_strategy = PutStrategies . get ( put_strategy ) or PutStrategies . copy self . lowercase_extensions = lowercase_extensions def put ( self , file , extension = None , put_strategy = None , simulate = False ): \"\"\"Store contents of `file` on disk using its content hash for the address. Args: file (mixed): Readable object or path to file. extension (str, optional): Optional extension to append to file when saving. put_strategy (mixed, optional): The strategy to use for adding files; may be a function or the string name of one of the built-in put strategies declared in :class:`PutStrategies` class. Defaults to :attr:`PutStrategies.copy`. simulate (bool, optional): Return the :class:`HashAddress` of the file that would be appended but don't do anything. Put strategies are functions ``(evercas, stream, filepath)`` where ``evercas`` is the :class:`EverCas` instance from which :meth:`put` was called; ``stream`` is the :class:`Stream` object representing the data to add; and ``filepath`` is the string absolute file path inside the EverCas where it needs to be saved. The put strategy function should create the path ``filepath`` containing the data in ``stream``. There are currently two built-in put strategies: \"copy\" (the default) and \"link\". \"link\" attempts to hard link the file into the EverCas if the platform and underlying filesystem support it, and falls back to \"copy\" behaviour. Returns: HashAddress: File's hash address. \"\"\" stream = Stream ( file ) if extension and self . lowercase_extensions : extension = extension . lower () with closing ( stream ): id = self . computehash ( stream ) filepath = self . idpath ( id , extension ) # Only move file if it doesn't already exist. if not os . path . isfile ( filepath ): is_duplicate = False if not simulate : self . makepath ( os . path . dirname ( filepath )) put_strategy = ( PutStrategies . get ( put_strategy ) or self . put_strategy or PutStrategies . copy ) put_strategy ( self , stream , filepath ) else : is_duplicate = True return HashAddress ( id , self . relpath ( filepath ), filepath , is_duplicate ) def putdir ( self , root , extensions = True , recursive = False , ** kwargs ): \"\"\"Put all files from a directory. Args: root (str): Path to the directory to add. extensions (bool, optional): Whether to add extensions when saving (extension will be taken from input file). Defaults to ``True``. recursive (bool, optional): Find files recursively in ``root``. Defaults to ``False``. put_strategy (mixed, optional): same as :meth:`put`. simulate (boo, optional): same as :meth:`put`. Yields :class:`HashAddress`es for all added files. \"\"\" for file in find_files ( root , recursive = recursive ): extension = os . path . splitext ( file )[ 1 ] if extensions else None address = self . put ( file , extension = extension , ** kwargs ) yield ( file , address ) def _mktempfile ( self , stream ): \"\"\"Create a named temporary file from a :class:`Stream` object and return its filename. \"\"\" tmp = NamedTemporaryFile ( delete = False ) if self . fmode is not None : oldmask = os . umask ( 0 ) try : os . chmod ( tmp . name , self . fmode ) finally : os . umask ( oldmask ) for data in stream : tmp . write ( to_bytes ( data )) tmp . close () return tmp . name def get ( self , file ): \"\"\"Return :class:`HashAdress` from given id or path. If `file` does not refer to a valid file, then ``None`` is returned. Args: file (str): Address ID or path of file. Returns: HashAddress: File's hash address. \"\"\" realpath = self . realpath ( file ) if realpath is None : return None else : return HashAddress ( self . unshard ( realpath ), self . relpath ( realpath ), realpath ) def open ( self , file , mode = \"rb\" ): \"\"\"Return open buffer object from given id or path. Args: file (str): Address ID or path of file. mode (str, optional): Mode to open file in. Defaults to ``'rb'``. Returns: Buffer: An ``io`` buffer dependent on the `mode`. Raises: IOError: If file doesn't exist. \"\"\" realpath = self . realpath ( file ) if realpath is None : raise IOError ( \"Could not locate file: {0} \" . format ( file )) return io . open ( realpath , mode ) def delete ( self , file ): \"\"\"Delete file using id or path. Remove any empty directories after deleting. No exception is raised if file doesn't exist. Args: file (str): Address ID or path of file. \"\"\" realpath = self . realpath ( file ) if realpath is None : return try : os . remove ( realpath ) except OSError : # pragma: no cover pass else : self . remove_empty ( os . path . dirname ( realpath )) def remove_empty ( self , subpath ): \"\"\"Successively remove all empty folders starting with `subpath` and proceeding \"up\" through directory tree until reaching the :attr:`root` folder. \"\"\" # Don't attempt to remove any folders if subpath is not a # subdirectory of the root directory. if not self . haspath ( subpath ): return while subpath != self . root : if len ( os . listdir ( subpath )) > 0 or os . path . islink ( subpath ): break os . rmdir ( subpath ) subpath = os . path . dirname ( subpath ) def files ( self ): \"\"\"Return generator that yields all files in the :attr:`root` directory. \"\"\" for file in find_files ( self . root , recursive = True ): yield os . path . abspath ( file ) def folders ( self ): \"\"\"Return generator that yields all folders in the :attr:`root` directory that contain files. \"\"\" for folder , subfolders , files in os . walk ( self . root ): if files : yield folder def count ( self ): \"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\" count = 0 for _ in self : count += 1 return count def size ( self ): \"\"\"Return the total size in bytes of all files in the :attr:`root` directory. \"\"\" total = 0 for path in self . files (): total += os . path . getsize ( path ) return total def exists ( self , file ): \"\"\"Check whether a given file id or path exists on disk.\"\"\" return bool ( self . realpath ( file )) def haspath ( self , path ): \"\"\"Return whether `path` is a subdirectory of the :attr:`root` directory. \"\"\" return issubdir ( path , self . root ) def makepath ( self , path ): \"\"\"Physically create the folder path on disk.\"\"\" try : os . makedirs ( path , self . dmode ) except FileExistsError : assert os . path . isdir ( path ), \"expected {} to be a directory\" . format ( path ) def relpath ( self , path ): \"\"\"Return `path` relative to the :attr:`root` directory.\"\"\" return os . path . relpath ( path , self . root ) def realpath ( self , file ): \"\"\"Attempt to determine the real path of a file id or path through successive checking of candidate paths. If the real path is stored with an extension, the path is considered a match if the basename matches the expected file path of the id. \"\"\" # Check for absoluate path. if os . path . isfile ( file ): return file # Check for relative path. relpath = os . path . join ( self . root , file ) if os . path . isfile ( relpath ): return relpath # Check for sharded path. filepath = self . idpath ( file ) if os . path . isfile ( filepath ): return filepath # Check for sharded path with any extension. paths = glob . glob ( \" {0} .*\" . format ( filepath )) if paths : return paths [ 0 ] # Could not determine a match. return None def idpath ( self , id , extension = \"\" ): \"\"\"Build the file path for a given hash id. Optionally, append a file extension. \"\"\" paths = self . shard ( id ) if extension and not extension . startswith ( os . extsep ): extension = os . extsep + extension elif not extension : extension = \"\" return os . path . join ( self . root , * paths ) + extension def computehash ( self , stream ): \"\"\"Compute hash of file using :attr:`algorithm`.\"\"\" hashobj = hashlib . new ( self . algorithm ) for data in stream : hashobj . update ( to_bytes ( data )) return hashobj . hexdigest () def shard ( self , id ): \"\"\"Shard content ID into subfolders.\"\"\" return shard ( id , self . depth , self . width ) def unshard ( self , path ): \"\"\"Unshard path to determine hash value.\"\"\" if not self . haspath ( path ): raise ValueError ( \"Cannot unshard path. The path {0!r} is not \" \"a subdirectory of the root directory {1!r} \" . format ( path , self . root ) ) return os . path . splitext ( self . relpath ( path ))[ 0 ] . replace ( os . sep , \"\" ) def repair ( self , extensions = True ): \"\"\"Repair any file locations whose content address doesn't match it's file path. \"\"\" repaired = [] corrupted = tuple ( self . corrupted ( extensions = extensions )) oldmask = os . umask ( 0 ) try : for path , address in corrupted : if os . path . isfile ( address . abspath ): # File already exists so just delete corrupted path. os . remove ( path ) else : # File doesn't exists so move it. self . makepath ( os . path . dirname ( address . abspath )) shutil . move ( path , address . abspath ) os . chmod ( address . abspath , self . fmode ) repaired . append (( path , address )) finally : os . umask ( oldmask ) return repaired def corrupted ( self , extensions = True ): \"\"\"Return generator that yields corrupted files as ``(path, address)`` where ``path`` is the path of the corrupted file and ``address`` is the :class:`HashAddress` of the expected location. \"\"\" for path in self . files (): stream = Stream ( path ) with closing ( stream ): id = self . computehash ( stream ) extension = os . path . splitext ( path )[ 1 ] if extensions else None expected_path = self . idpath ( id , extension ) if expected_path != path : yield ( path , HashAddress ( id , self . relpath ( expected_path ), expected_path ), ) def __contains__ ( self , file ): \"\"\"Return whether a given file id or path is contained in the :attr:`root` directory. \"\"\" return self . exists ( file ) def __iter__ ( self ): \"\"\"Iterate over all files in the :attr:`root` directory.\"\"\" return self . files () def __len__ ( self ): \"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\" return self . count ()","title":"EverCas"},{"location":"api/#evercas.evercas.EverCas.__contains__","text":"Return whether a given file id or path is contained in the :attr: root directory. Source code in evercas/evercas.py 389 390 391 392 393 def __contains__ ( self , file ): \"\"\"Return whether a given file id or path is contained in the :attr:`root` directory. \"\"\" return self . exists ( file )","title":"__contains__()"},{"location":"api/#evercas.evercas.EverCas.__iter__","text":"Iterate over all files in the :attr: root directory. Source code in evercas/evercas.py 395 396 397 def __iter__ ( self ): \"\"\"Iterate over all files in the :attr:`root` directory.\"\"\" return self . files ()","title":"__iter__()"},{"location":"api/#evercas.evercas.EverCas.__len__","text":"Return count of the number of files in the :attr: root directory. Source code in evercas/evercas.py 399 400 401 def __len__ ( self ): \"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\" return self . count ()","title":"__len__()"},{"location":"api/#evercas.evercas.EverCas.computehash","text":"Compute hash of file using :attr: algorithm . Source code in evercas/evercas.py 323 324 325 326 327 328 def computehash ( self , stream ): \"\"\"Compute hash of file using :attr:`algorithm`.\"\"\" hashobj = hashlib . new ( self . algorithm ) for data in stream : hashobj . update ( to_bytes ( data )) return hashobj . hexdigest ()","title":"computehash()"},{"location":"api/#evercas.evercas.EverCas.corrupted","text":"Return generator that yields corrupted files as (path, address) where path is the path of the corrupted file and address is the :class: HashAddress of the expected location. Source code in evercas/evercas.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def corrupted ( self , extensions = True ): \"\"\"Return generator that yields corrupted files as ``(path, address)`` where ``path`` is the path of the corrupted file and ``address`` is the :class:`HashAddress` of the expected location. \"\"\" for path in self . files (): stream = Stream ( path ) with closing ( stream ): id = self . computehash ( stream ) extension = os . path . splitext ( path )[ 1 ] if extensions else None expected_path = self . idpath ( id , extension ) if expected_path != path : yield ( path , HashAddress ( id , self . relpath ( expected_path ), expected_path ), )","title":"corrupted()"},{"location":"api/#evercas.evercas.EverCas.count","text":"Return count of the number of files in the :attr: root directory. Source code in evercas/evercas.py 243 244 245 246 247 248 def count ( self ): \"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\" count = 0 for _ in self : count += 1 return count","title":"count()"},{"location":"api/#evercas.evercas.EverCas.delete","text":"Delete file using id or path. Remove any empty directories after deleting. No exception is raised if file doesn't exist. Parameters: Name Type Description Default file str Address ID or path of file. required Source code in evercas/evercas.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def delete ( self , file ): \"\"\"Delete file using id or path. Remove any empty directories after deleting. No exception is raised if file doesn't exist. Args: file (str): Address ID or path of file. \"\"\" realpath = self . realpath ( file ) if realpath is None : return try : os . remove ( realpath ) except OSError : # pragma: no cover pass else : self . remove_empty ( os . path . dirname ( realpath ))","title":"delete()"},{"location":"api/#evercas.evercas.EverCas.exists","text":"Check whether a given file id or path exists on disk. Source code in evercas/evercas.py 261 262 263 def exists ( self , file ): \"\"\"Check whether a given file id or path exists on disk.\"\"\" return bool ( self . realpath ( file ))","title":"exists()"},{"location":"api/#evercas.evercas.EverCas.files","text":"Return generator that yields all files in the :attr: root directory. Source code in evercas/evercas.py 228 229 230 231 232 233 def files ( self ): \"\"\"Return generator that yields all files in the :attr:`root` directory. \"\"\" for file in find_files ( self . root , recursive = True ): yield os . path . abspath ( file )","title":"files()"},{"location":"api/#evercas.evercas.EverCas.folders","text":"Return generator that yields all folders in the :attr: root directory that contain files. Source code in evercas/evercas.py 235 236 237 238 239 240 241 def folders ( self ): \"\"\"Return generator that yields all folders in the :attr:`root` directory that contain files. \"\"\" for folder , subfolders , files in os . walk ( self . root ): if files : yield folder","title":"folders()"},{"location":"api/#evercas.evercas.EverCas.get","text":"Return :class: HashAdress from given id or path. If file does not refer to a valid file, then None is returned. Parameters: Name Type Description Default file str Address ID or path of file. required Returns: Name Type Description HashAddress File's hash address. Source code in evercas/evercas.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def get ( self , file ): \"\"\"Return :class:`HashAdress` from given id or path. If `file` does not refer to a valid file, then ``None`` is returned. Args: file (str): Address ID or path of file. Returns: HashAddress: File's hash address. \"\"\" realpath = self . realpath ( file ) if realpath is None : return None else : return HashAddress ( self . unshard ( realpath ), self . relpath ( realpath ), realpath )","title":"get()"},{"location":"api/#evercas.evercas.EverCas.haspath","text":"Return whether path is a subdirectory of the :attr: root directory. Source code in evercas/evercas.py 265 266 267 268 269 def haspath ( self , path ): \"\"\"Return whether `path` is a subdirectory of the :attr:`root` directory. \"\"\" return issubdir ( path , self . root )","title":"haspath()"},{"location":"api/#evercas.evercas.EverCas.idpath","text":"Build the file path for a given hash id. Optionally, append a file extension. Source code in evercas/evercas.py 310 311 312 313 314 315 316 317 318 319 320 321 def idpath ( self , id , extension = \"\" ): \"\"\"Build the file path for a given hash id. Optionally, append a file extension. \"\"\" paths = self . shard ( id ) if extension and not extension . startswith ( os . extsep ): extension = os . extsep + extension elif not extension : extension = \"\" return os . path . join ( self . root , * paths ) + extension","title":"idpath()"},{"location":"api/#evercas.evercas.EverCas.makepath","text":"Physically create the folder path on disk. Source code in evercas/evercas.py 271 272 273 274 275 276 def makepath ( self , path ): \"\"\"Physically create the folder path on disk.\"\"\" try : os . makedirs ( path , self . dmode ) except FileExistsError : assert os . path . isdir ( path ), \"expected {} to be a directory\" . format ( path )","title":"makepath()"},{"location":"api/#evercas.evercas.EverCas.open","text":"Return open buffer object from given id or path. Parameters: Name Type Description Default file str Address ID or path of file. required mode str Mode to open file in. Defaults to 'rb' . 'rb' Returns: Name Type Description Buffer An io buffer dependent on the mode . Raises: Type Description IOError If file doesn't exist. Source code in evercas/evercas.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def open ( self , file , mode = \"rb\" ): \"\"\"Return open buffer object from given id or path. Args: file (str): Address ID or path of file. mode (str, optional): Mode to open file in. Defaults to ``'rb'``. Returns: Buffer: An ``io`` buffer dependent on the `mode`. Raises: IOError: If file doesn't exist. \"\"\" realpath = self . realpath ( file ) if realpath is None : raise IOError ( \"Could not locate file: {0} \" . format ( file )) return io . open ( realpath , mode )","title":"open()"},{"location":"api/#evercas.evercas.EverCas.put","text":"Store contents of file on disk using its content hash for the address. Parameters: Name Type Description Default file mixed Readable object or path to file. required extension str Optional extension to append to file when saving. None put_strategy mixed The strategy to use for adding files; may be a function or the string name of one of the built-in put strategies declared in :class: PutStrategies class. Defaults to :attr: PutStrategies.copy . None simulate bool Return the :class: HashAddress of the file that would be appended but don't do anything. False Put strategies are functions (evercas, stream, filepath) where evercas is the :class: EverCas instance from which :meth: put was called; stream is the :class: Stream object representing the data to add; and filepath is the string absolute file path inside the EverCas where it needs to be saved. The put strategy function should create the path filepath containing the data in stream . There are currently two built-in put strategies: \"copy\" (the default) and \"link\". \"link\" attempts to hard link the file into the EverCas if the platform and underlying filesystem support it, and falls back to \"copy\" behaviour. Returns: Name Type Description HashAddress File's hash address. Source code in evercas/evercas.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def put ( self , file , extension = None , put_strategy = None , simulate = False ): \"\"\"Store contents of `file` on disk using its content hash for the address. Args: file (mixed): Readable object or path to file. extension (str, optional): Optional extension to append to file when saving. put_strategy (mixed, optional): The strategy to use for adding files; may be a function or the string name of one of the built-in put strategies declared in :class:`PutStrategies` class. Defaults to :attr:`PutStrategies.copy`. simulate (bool, optional): Return the :class:`HashAddress` of the file that would be appended but don't do anything. Put strategies are functions ``(evercas, stream, filepath)`` where ``evercas`` is the :class:`EverCas` instance from which :meth:`put` was called; ``stream`` is the :class:`Stream` object representing the data to add; and ``filepath`` is the string absolute file path inside the EverCas where it needs to be saved. The put strategy function should create the path ``filepath`` containing the data in ``stream``. There are currently two built-in put strategies: \"copy\" (the default) and \"link\". \"link\" attempts to hard link the file into the EverCas if the platform and underlying filesystem support it, and falls back to \"copy\" behaviour. Returns: HashAddress: File's hash address. \"\"\" stream = Stream ( file ) if extension and self . lowercase_extensions : extension = extension . lower () with closing ( stream ): id = self . computehash ( stream ) filepath = self . idpath ( id , extension ) # Only move file if it doesn't already exist. if not os . path . isfile ( filepath ): is_duplicate = False if not simulate : self . makepath ( os . path . dirname ( filepath )) put_strategy = ( PutStrategies . get ( put_strategy ) or self . put_strategy or PutStrategies . copy ) put_strategy ( self , stream , filepath ) else : is_duplicate = True return HashAddress ( id , self . relpath ( filepath ), filepath , is_duplicate )","title":"put()"},{"location":"api/#evercas.evercas.EverCas.putdir","text":"Put all files from a directory. Parameters: Name Type Description Default root str Path to the directory to add. required extensions bool Whether to add extensions when saving (extension will be taken from input file). Defaults to True . True recursive bool Find files recursively in root . Defaults to False . False put_strategy mixed same as :meth: put . required simulate boo same as :meth: put . required Yields :class: HashAddress es for all added files. Source code in evercas/evercas.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def putdir ( self , root , extensions = True , recursive = False , ** kwargs ): \"\"\"Put all files from a directory. Args: root (str): Path to the directory to add. extensions (bool, optional): Whether to add extensions when saving (extension will be taken from input file). Defaults to ``True``. recursive (bool, optional): Find files recursively in ``root``. Defaults to ``False``. put_strategy (mixed, optional): same as :meth:`put`. simulate (boo, optional): same as :meth:`put`. Yields :class:`HashAddress`es for all added files. \"\"\" for file in find_files ( root , recursive = recursive ): extension = os . path . splitext ( file )[ 1 ] if extensions else None address = self . put ( file , extension = extension , ** kwargs ) yield ( file , address )","title":"putdir()"},{"location":"api/#evercas.evercas.EverCas.realpath","text":"Attempt to determine the real path of a file id or path through successive checking of candidate paths. If the real path is stored with an extension, the path is considered a match if the basename matches the expected file path of the id. Source code in evercas/evercas.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def realpath ( self , file ): \"\"\"Attempt to determine the real path of a file id or path through successive checking of candidate paths. If the real path is stored with an extension, the path is considered a match if the basename matches the expected file path of the id. \"\"\" # Check for absoluate path. if os . path . isfile ( file ): return file # Check for relative path. relpath = os . path . join ( self . root , file ) if os . path . isfile ( relpath ): return relpath # Check for sharded path. filepath = self . idpath ( file ) if os . path . isfile ( filepath ): return filepath # Check for sharded path with any extension. paths = glob . glob ( \" {0} .*\" . format ( filepath )) if paths : return paths [ 0 ] # Could not determine a match. return None","title":"realpath()"},{"location":"api/#evercas.evercas.EverCas.relpath","text":"Return path relative to the :attr: root directory. Source code in evercas/evercas.py 278 279 280 def relpath ( self , path ): \"\"\"Return `path` relative to the :attr:`root` directory.\"\"\" return os . path . relpath ( path , self . root )","title":"relpath()"},{"location":"api/#evercas.evercas.EverCas.remove_empty","text":"Successively remove all empty folders starting with subpath and proceeding \"up\" through directory tree until reaching the :attr: root folder. Source code in evercas/evercas.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def remove_empty ( self , subpath ): \"\"\"Successively remove all empty folders starting with `subpath` and proceeding \"up\" through directory tree until reaching the :attr:`root` folder. \"\"\" # Don't attempt to remove any folders if subpath is not a # subdirectory of the root directory. if not self . haspath ( subpath ): return while subpath != self . root : if len ( os . listdir ( subpath )) > 0 or os . path . islink ( subpath ): break os . rmdir ( subpath ) subpath = os . path . dirname ( subpath )","title":"remove_empty()"},{"location":"api/#evercas.evercas.EverCas.repair","text":"Repair any file locations whose content address doesn't match it's file path. Source code in evercas/evercas.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def repair ( self , extensions = True ): \"\"\"Repair any file locations whose content address doesn't match it's file path. \"\"\" repaired = [] corrupted = tuple ( self . corrupted ( extensions = extensions )) oldmask = os . umask ( 0 ) try : for path , address in corrupted : if os . path . isfile ( address . abspath ): # File already exists so just delete corrupted path. os . remove ( path ) else : # File doesn't exists so move it. self . makepath ( os . path . dirname ( address . abspath )) shutil . move ( path , address . abspath ) os . chmod ( address . abspath , self . fmode ) repaired . append (( path , address )) finally : os . umask ( oldmask ) return repaired","title":"repair()"},{"location":"api/#evercas.evercas.EverCas.shard","text":"Shard content ID into subfolders. Source code in evercas/evercas.py 330 331 332 def shard ( self , id ): \"\"\"Shard content ID into subfolders.\"\"\" return shard ( id , self . depth , self . width )","title":"shard()"},{"location":"api/#evercas.evercas.EverCas.size","text":"Return the total size in bytes of all files in the :attr: root directory. Source code in evercas/evercas.py 250 251 252 253 254 255 256 257 258 259 def size ( self ): \"\"\"Return the total size in bytes of all files in the :attr:`root` directory. \"\"\" total = 0 for path in self . files (): total += os . path . getsize ( path ) return total","title":"size()"},{"location":"api/#evercas.evercas.EverCas.unshard","text":"Unshard path to determine hash value. Source code in evercas/evercas.py 334 335 336 337 338 339 340 341 342 def unshard ( self , path ): \"\"\"Unshard path to determine hash value.\"\"\" if not self . haspath ( path ): raise ValueError ( \"Cannot unshard path. The path {0!r} is not \" \"a subdirectory of the root directory {1!r} \" . format ( path , self . root ) ) return os . path . splitext ( self . relpath ( path ))[ 0 ] . replace ( os . sep , \"\" )","title":"unshard()"},{"location":"api/#evercas.evercas.HashAddress","text":"Bases: namedtuple ( HashAddress , [ id , relpath , abspath , is_duplicate ]) File address containing file's path on disk and it's content hash ID. Attributes: Name Type Description id str Hash ID (hexdigest) of file contents. relpath str Relative path location to :attr: EverCas.root . abspath str Absoluate path location of file on disk. is_duplicate boolean Whether the hash address created was a duplicate of a previously existing file. Can only be True after a put operation. Defaults to False . Source code in evercas/evercas.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 class HashAddress ( namedtuple ( \"HashAddress\" , [ \"id\" , \"relpath\" , \"abspath\" , \"is_duplicate\" ]) ): \"\"\"File address containing file's path on disk and it's content hash ID. Attributes: id (str): Hash ID (hexdigest) of file contents. relpath (str): Relative path location to :attr:`EverCas.root`. abspath (str): Absoluate path location of file on disk. is_duplicate (boolean, optional): Whether the hash address created was a duplicate of a previously existing file. Can only be ``True`` after a put operation. Defaults to ``False``. \"\"\" def __new__ ( cls , id , relpath , abspath , is_duplicate = False ): return super ( HashAddress , cls ) . __new__ ( cls , id , relpath , abspath , is_duplicate )","title":"HashAddress"},{"location":"api/#evercas.evercas.PutStrategies","text":"Namespace for built-in put strategies. Should not be instantiated. Use the :meth: get static method to look up a strategy by name, or directly reference one of the included class methods. Source code in evercas/evercas.py 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 class PutStrategies : \"\"\"Namespace for built-in put strategies. Should not be instantiated. Use the :meth:`get` static method to look up a strategy by name, or directly reference one of the included class methods. \"\"\" @classmethod def get ( cls , method ): \"\"\"Look up a stragegy by name string. You can also pass a function which will be returned as is.\"\"\" if method : if method == \"get\" : raise ValueError ( \"invalid put strategy name, 'get'\" ) return method if callable ( method ) else getattr ( cls , method ) @staticmethod def copy ( evercas , src_stream , dst_path ): \"\"\"The default copy put strategy, writes the file object to a temporary file on disk and then moves it into place.\"\"\" shutil . move ( evercas . _mktempfile ( src_stream ), dst_path ) if hasattr ( os , \"link\" ): @classmethod def link ( cls , evercas , src_stream , dst_path ): \"\"\"Use os.link if available to create a hard link to the original file if the EverCas and the original file reside on the same filesystem and the filesystem supports hard links.\"\"\" # Get the original file path exposed by the Stream instance src_path = src_stream . name # No path available because e.g. a StringIO was used if not src_path : # Just copy return cls . copy ( evercas , src_stream , dst_path ) try : # Try to create the hard link os . link ( src_path , dst_path ) except EnvironmentError as e : # These are link specific errors. If any of these 3 are raised # we try to copy instead # EMLINK - src already has the maximum number of links to it # EXDEV - invalid cross-device link # EPERM - the dst filesystem does not support hard links # (note EPERM could also be another permissions error; these # will be raised again when we try to copy) if e . errno not in ( errno . EMLINK , errno . EXDEV , errno . EPERM ): raise return cls . copy ( evercas , src_stream , dst_path ) else : # After creating the hard link, make sure it has the correct # file permissions os . chmod ( dst_path , evercas . fmode ) else : # Platform does not support os.link, so use the default copy strategy # instead link = copy","title":"PutStrategies"},{"location":"api/#evercas.evercas.PutStrategies.copy","text":"The default copy put strategy, writes the file object to a temporary file on disk and then moves it into place. Source code in evercas/evercas.py 538 539 540 541 542 @staticmethod def copy ( evercas , src_stream , dst_path ): \"\"\"The default copy put strategy, writes the file object to a temporary file on disk and then moves it into place.\"\"\" shutil . move ( evercas . _mktempfile ( src_stream ), dst_path )","title":"copy()"},{"location":"api/#evercas.evercas.PutStrategies.get","text":"Look up a stragegy by name string. You can also pass a function which will be returned as is. Source code in evercas/evercas.py 529 530 531 532 533 534 535 536 @classmethod def get ( cls , method ): \"\"\"Look up a stragegy by name string. You can also pass a function which will be returned as is.\"\"\" if method : if method == \"get\" : raise ValueError ( \"invalid put strategy name, 'get'\" ) return method if callable ( method ) else getattr ( cls , method )","title":"get()"},{"location":"api/#evercas.evercas.PutStrategies.link","text":"Use os.link if available to create a hard link to the original file if the EverCas and the original file reside on the same filesystem and the filesystem supports hard links. Source code in evercas/evercas.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 @classmethod def link ( cls , evercas , src_stream , dst_path ): \"\"\"Use os.link if available to create a hard link to the original file if the EverCas and the original file reside on the same filesystem and the filesystem supports hard links.\"\"\" # Get the original file path exposed by the Stream instance src_path = src_stream . name # No path available because e.g. a StringIO was used if not src_path : # Just copy return cls . copy ( evercas , src_stream , dst_path ) try : # Try to create the hard link os . link ( src_path , dst_path ) except EnvironmentError as e : # These are link specific errors. If any of these 3 are raised # we try to copy instead # EMLINK - src already has the maximum number of links to it # EXDEV - invalid cross-device link # EPERM - the dst filesystem does not support hard links # (note EPERM could also be another permissions error; these # will be raised again when we try to copy) if e . errno not in ( errno . EMLINK , errno . EXDEV , errno . EPERM ): raise return cls . copy ( evercas , src_stream , dst_path ) else : # After creating the hard link, make sure it has the correct # file permissions os . chmod ( dst_path , evercas . fmode )","title":"link()"},{"location":"api/#evercas.evercas.Stream","text":"Bases: object Common interface for file-like objects. The input obj can be a file-like object or a path to a file. If obj is a path to a file, then it will be opened until :meth: close is called. If obj is a file-like object, then it's original position will be restored when :meth: close is called instead of closing the object automatically. Closing of the stream is deferred to whatever process passed the stream in. Successive readings of the stream is supported without having to manually set it's position back to 0 . Source code in evercas/evercas.py 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 class Stream ( object ): \"\"\"Common interface for file-like objects. The input `obj` can be a file-like object or a path to a file. If `obj` is a path to a file, then it will be opened until :meth:`close` is called. If `obj` is a file-like object, then it's original position will be restored when :meth:`close` is called instead of closing the object automatically. Closing of the stream is deferred to whatever process passed the stream in. Successive readings of the stream is supported without having to manually set it's position back to ``0``. \"\"\" def __init__ ( self , obj ): if hasattr ( obj , \"read\" ): pos = obj . tell () elif os . path . isfile ( obj ): obj = io . open ( obj , \"rb\" ) pos = None else : raise ValueError ( \"Object must be a valid file path or a readable object\" ) try : file_stat = os . stat ( obj . name ) buffer_size = file_stat . st_blksize except Exception : buffer_size = 8192 try : # Expose the original file path if available. # This allows put strategies to use OS functions, working with # paths, instead of being limited to the API provided by Python # file-like objects # name property can also hold int fd, so we make it None in that # case self . name = None if isinstance ( obj . name , int ) else obj . name except AttributeError : self . name = None self . _obj = obj self . _pos = pos self . _buffer_size = buffer_size def __iter__ ( self ): \"\"\"Read underlying IO object and yield results. Return object to original position if we didn't open it originally. \"\"\" self . _obj . seek ( 0 ) while True : data = self . _obj . read ( self . _buffer_size ) if not data : break yield data if self . _pos is not None : self . _obj . seek ( self . _pos ) def close ( self ): \"\"\"Close underlying IO object if we opened it, else return it to original position. \"\"\" if self . _pos is None : self . _obj . close () else : self . _obj . seek ( self . _pos )","title":"Stream"},{"location":"api/#evercas.evercas.Stream.__iter__","text":"Read underlying IO object and yield results. Return object to original position if we didn't open it originally. Source code in evercas/evercas.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def __iter__ ( self ): \"\"\"Read underlying IO object and yield results. Return object to original position if we didn't open it originally. \"\"\" self . _obj . seek ( 0 ) while True : data = self . _obj . read ( self . _buffer_size ) if not data : break yield data if self . _pos is not None : self . _obj . seek ( self . _pos )","title":"__iter__()"},{"location":"api/#evercas.evercas.Stream.close","text":"Close underlying IO object if we opened it, else return it to original position. Source code in evercas/evercas.py 512 513 514 515 516 517 518 519 def close ( self ): \"\"\"Close underlying IO object if we opened it, else return it to original position. \"\"\" if self . _pos is None : self . _obj . close () else : self . _obj . seek ( self . _pos )","title":"close()"},{"location":"changelog/","text":"Changelog v0.7.2 (2019-10-24) Fix out-of-memory issue when computing file ID hashes of large files. v0.7.1 (2018-10-13) Replace usage of distutils.dir_util.mkpath with os.path.makedirs . v0.7.0 (2016-04-19) Use shutil.move instead of shutil.copy to move temporary file created during put operation to HashFS directory. v0.6.0 (2015-10-19) Add faster scandir package for iterating over files/folders when platform is Python \\< 3.5. Scandir implementation was added to os module starting with Python 3.5. v0.5.0 (2015-07-02) Rename private method HashFS.copy to HashFS._copy . Add is_duplicate attribute to HashAddress . Make HashFS.put() return HashAddress with is_duplicate=True when file with same hash already exists on disk. v0.4.0 (2015-06-03) Add HashFS.size() method that returns the size of all files in bytes. Add HashFS.count() / HashFS.__len__() methods that return the count of all files. Add HashFS.__iter__() method to support iteration. Proxies to HashFS.files() . Add HashFS.__contains__() method to support in operator. Proxies to HashFS.exists() . Don\\'t create the root directory (if it doesn\\'t exist) until at least one file has been added. Fix HashFS.repair() not using extensions argument properly. v0.3.0 (2015-06-02) Rename HashFS.length parameter/property to width . ( breaking change ) v0.2.0 (2015-05-29) Rename HashFS.get to HashFS.open . ( breaking change ) Add HashFS.get() method that returns a HashAddress or None given a file ID or path. v0.1.0 (2015-05-28) Add HashFS.get() method that retrieves a reader object given a file ID or path. Add HashFS.delete() method that deletes a file ID or path. Add HashFS.folders() method that returns the folder paths that directly contain files (i.e. subpaths that only contain folders are ignored). Add HashFS.detokenize() method that returns the file ID contained in a file path. Add HashFS.repair() method that reindexes any files under root directory whose file path doesn\\'t not match its tokenized file ID. Rename Address classs to HashAddress . ( breaking change ) Rename HashAddress.digest to HashAddress.id . ( breaking change ) Rename HashAddress.path to HashAddress.abspath . ( breaking change ) Add HashAddress.relpath which represents path relative to HashFS.root . v0.0.1 (2015-05-27) First release. Add HashFS class. Add HashFS.put() method that saves a file path or file-like object by content hash. Add HashFS.files() method that returns all files under root directory. Add HashFS.exists() which checks either a file hash or file path for existence.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v072-2019-10-24","text":"Fix out-of-memory issue when computing file ID hashes of large files.","title":"v0.7.2 (2019-10-24)"},{"location":"changelog/#v071-2018-10-13","text":"Replace usage of distutils.dir_util.mkpath with os.path.makedirs .","title":"v0.7.1 (2018-10-13)"},{"location":"changelog/#v070-2016-04-19","text":"Use shutil.move instead of shutil.copy to move temporary file created during put operation to HashFS directory.","title":"v0.7.0 (2016-04-19)"},{"location":"changelog/#v060-2015-10-19","text":"Add faster scandir package for iterating over files/folders when platform is Python \\< 3.5. Scandir implementation was added to os module starting with Python 3.5.","title":"v0.6.0 (2015-10-19)"},{"location":"changelog/#v050-2015-07-02","text":"Rename private method HashFS.copy to HashFS._copy . Add is_duplicate attribute to HashAddress . Make HashFS.put() return HashAddress with is_duplicate=True when file with same hash already exists on disk.","title":"v0.5.0 (2015-07-02)"},{"location":"changelog/#v040-2015-06-03","text":"Add HashFS.size() method that returns the size of all files in bytes. Add HashFS.count() / HashFS.__len__() methods that return the count of all files. Add HashFS.__iter__() method to support iteration. Proxies to HashFS.files() . Add HashFS.__contains__() method to support in operator. Proxies to HashFS.exists() . Don\\'t create the root directory (if it doesn\\'t exist) until at least one file has been added. Fix HashFS.repair() not using extensions argument properly.","title":"v0.4.0 (2015-06-03)"},{"location":"changelog/#v030-2015-06-02","text":"Rename HashFS.length parameter/property to width . ( breaking change )","title":"v0.3.0 (2015-06-02)"},{"location":"changelog/#v020-2015-05-29","text":"Rename HashFS.get to HashFS.open . ( breaking change ) Add HashFS.get() method that returns a HashAddress or None given a file ID or path.","title":"v0.2.0 (2015-05-29)"},{"location":"changelog/#v010-2015-05-28","text":"Add HashFS.get() method that retrieves a reader object given a file ID or path. Add HashFS.delete() method that deletes a file ID or path. Add HashFS.folders() method that returns the folder paths that directly contain files (i.e. subpaths that only contain folders are ignored). Add HashFS.detokenize() method that returns the file ID contained in a file path. Add HashFS.repair() method that reindexes any files under root directory whose file path doesn\\'t not match its tokenized file ID. Rename Address classs to HashAddress . ( breaking change ) Rename HashAddress.digest to HashAddress.id . ( breaking change ) Rename HashAddress.path to HashAddress.abspath . ( breaking change ) Add HashAddress.relpath which represents path relative to HashFS.root .","title":"v0.1.0 (2015-05-28)"},{"location":"changelog/#v001-2015-05-27","text":"First release. Add HashFS class. Add HashFS.put() method that saves a file path or file-like object by content hash. Add HashFS.files() method that returns all files under root directory. Add HashFS.exists() which checks either a file hash or file path for existence.","title":"v0.0.1 (2015-05-27)"},{"location":"versioning/","text":"Versioning Currently the project is in early stages, so expect the API to frequently change. Starting with version 1.0, this project will follow Semantic Versioning with the following caveats: Only the public API (i.e. the objects imported into the evercas module) will maintain backwards compatibility between MINOR version bumps. Objects within any other parts of the library are not guaranteed to not break between MINOR version bumps. With that in mind, it is recommended to only use or import objects from the main module, evercas.","title":"Versioning"},{"location":"versioning/#versioning","text":"Currently the project is in early stages, so expect the API to frequently change. Starting with version 1.0, this project will follow Semantic Versioning with the following caveats: Only the public API (i.e. the objects imported into the evercas module) will maintain backwards compatibility between MINOR version bumps. Objects within any other parts of the library are not guaranteed to not break between MINOR version bumps. With that in mind, it is recommended to only use or import objects from the main module, evercas.","title":"Versioning"}]}